* Expressions
- Expressions include concrete values, variables, and also functions
- Functions are expressions that are applied to an argument, and hence
  can be /reduced/ or /evaluated/
* Infix/Prefix
#+BEGIN_SRC text
  div (prefix) -> `div` (infix)
  + (infix) -> (+) (prefix)
#+END_SRC
* Let vs Where
Let introduces an expression, so it can be used wherever you can have
an expression, but where is a declaration and is bound to a
surrounding syntactic construct.
* Typeclasses
Typeclasses are a way of adding additional functionality that is
reusable across all the types that have instances of that typeclass.
=Num= is a typeclass for most numeric types, that provide the basic
operators =(+)=, =(-)=, =(*)= , =(/)= etc.
* Datatype declaration
  A datatype declaration defines a type constructor and data
  constructors. Data constructors are the values of a particular type,
  and are also functions that let us create data, or values, of a
  particular type.
* Sectioning
  Refers to the partial application of infix operators.
#+BEGIN_SRC haskell
  let x = 5
  let y = (2^)
  let z = (^2)

  y x                             -- 32
  z x                             -- 25

  let celebrate = (++ " woot!")
  celebrate "naptime" -- "naptime woot!"
  celebrate "dogs" -- "dogs woot!"
#+END_SRC
* Types
** Polymorphism
1. Parametric polymorphism
   - Refers to type variables, or parameters, that are fully
     polymorphic
   - When unconstrained by a typeclass, the final concrete type could
     be anything
2. Constrained polymorphism
   - Puts typeclass constraints on the variable, decreasing the number
     of concrete types it could be, but increasing what you can
     actually do with it by defining and bringing into scope a set of
     operations

Numeric literals are polymorphic and stay so until given a more
specific type.
** Parametricity
 /parametricity/ means that the behaviour of a function with respect to
 the types its (parametric polymorphic) arguments is uniform. The
 behaviour cannot change just because it was applied to an argument of
 a different type.
** Making things more polymorphic
#+BEGIN_SRC haskell
  -- fromIntegral :: (Num b, Integral a) => a -> b
  -- e.g.
  6 / fromIntegral (length [1,2,3])
#+END_SRC
* Typeclasses
Where a declaration of a type defines how that particular type is
created, a declaration of a typeclass defines how a set of types are
consumed or used in computations.

As long as a type implements, or instantiates a typeclass, then
standard functions implemented on the typeclass can be used.

#+BEGIN_SRC haskell
  data DayOfWeek =
    Mon | Tue | Wed | Thu | Fri | Sat | Sun

  -- day of week and numerical day of month

  data Date =
    Date DayOfWeek Int
#+END_SRC

Because Eq is not derived in the typeclass, we need to instantiate one
of our own:

#+BEGIN_SRC haskell
  instance Eq DayOfWeek where
    (==) Mon Mon = True
    (==) Tue Tue = True
    (==) Wed Wed = True
    (==) Thu Thu = True
    (==) Fri Fri = True
    (==) Sat Sat = True
    (==) Sun Sun = True
    (==) _ _ = False

  instance Eq Date where
    (==) (Date weekday dayOfMonth) (Date weekday' dayOfMonth') =
      weekday == weekday' && dayOfMonth = dayOfMonth'
#+END_SRC

Typeclass instances are unique parings of the typeclass and a type.
They define the ways to implement the typeclass methods for that type.

** IO
An IO action is an action that, when performed, has side effects,
including reading from input and printing to the screen, and will
contain a return value.

In =IO ()=, =()= denotes an empty tuple, referred to as a /unit/. A
unit is both a value and a type, that has only one inhabitant.

** Summary
- A typeclass defines a set of functions and/or values;
- Types have instances of that typeclass
- The instances specify the ways that type uses the functions of the typeclass
* Lists
#+BEGIN_SRC haskell
  data [] a = [] | a : [a]
#+END_SRC
** Extracting portions of lists
#+BEGIN_SRC haskell
  take :: Int -> [a] -> [a]
  drop :: Int -> [a] -> [a]
  splitAt :: Int -> [a] -> ([a], [a])
#+END_SRC

#+BEGIN_SRC haskell
  takeWhile :: (a -> Bool) -> [a] -> [a]
  dropWhile :: (a -> Bool) -> [a] -> [a]
#+END_SRC
** Transforming lists of values
#+BEGIN_SRC haskell
  map :: (a -> b) -> [a] -> [b]
  fmap :: Functor f => (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
  map (+1) [1,2,3,4] -- [2,3,4,5]
  map (1-) [1,2,3,4] -- [0,-1,-2,-3]
#+END_SRC

#+BEGIN_SRC haskell
  filter :: (a -> Bool) -> [a] -> [a]
  filter _ [] = []
  filter pred (x:xs)
    | pred x = x : filter pred xs
    | otherwise = filter pred xs
#+END_SRC

#+BEGIN_SRC haskell
  zip :: [a] -> [b] -> [(a,b)]
  zip [1,2] [3,4] -- [(1,3), (2,4)]

  zipWith (+) [1,2,3] [10,11,12] -- [11,13,15]
#+END_SRC
** Folding lists
   Folds as a general concept are called /catamorphisms/.
   /Catamorphisms/ are a means of deconstructing data. If the spine of
   the list is the structure of a list, then a fold is what can reduce
   that structure.

#+BEGIN_SRC haskell
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr f z xs =
    case xs of
      [] -> z
      (x:xs) -> f x (foldr f z xs)
#+END_SRC
