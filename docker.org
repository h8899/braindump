#+TITLE: Docker 101
#+SUBTITLE: Hackerschool, NUS Hackers
#+DATE: 2017/10/14
#+AUTHOR: Jethro Kuan
#+EMAIL: jethrokuan95@gmail.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export

#+WWW: http://www.nushackers.org/
#+TWITTER: @nushackers

#+FAVICON: images/docker/docker.png
#+ICON: images/docker/docker.png
#+HASHTAG: #hackerschool #docker
* Load I/O Slides                                                  :noexport:
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'ox-ioslide)
#+END_SRC
* Why Containers
  :PROPERTIES:
  :FILL:     images/docker/cargo.jpg
  :END:
** Containers are Cheap
[[file:images/docker/container_vm.png]]
*** Containers are Cheap
#+ATTR_HTML: :class build fade
- Docker provides lightweight virtualization with almost zero
  overhead.
- Start and stop containers within seconds.
** Containers are Portable
Containers contain all the required software dependencies to run your
application.

Once a container is built, you can be sure it runs "the same way" on any
host operating system with the same Linux kernel.
* Containers in OSes
| Year |                                                                |
|------+----------------------------------------------------------------|
| 2006 | Process Containers, later renamed to cgroups                   |
| 2008 | LXC: implemented using cgroups and kernel namespaces           |
| 2013 | Docker: initially built on LXC, but now runs on =libcontainer= |
** 2006: Process Containers
[[file:images/docker/cgroups.png]]
** 2008: LXC Containers, and 2013: Docker
#+ATTR_HTML: :width 60%
[[file:images/docker/lxc_docker.png]]
* What is Docker?
Docker is a toolchain for managing containers.
#+ATTR_HTML: :width 60%
[[file:images/docker/docker_architecture.png]]
* What You'll Do Today
You'll be packaging a simple node application with Docker. You'll also
be running Docker for both development and production environments!

* Docker Basics
:PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
:END:
** Pulling images
#+BEGIN_SRC sh
  docker pull alpine
#+END_SRC
*** Alpine?
=alpine= is an image for a tiny Linux distribution, used by Docker for
most of its official images.

A container image is a lightweight, stand-alone, executable package of
a piece of software that includes everything needed to run it: code,
runtime, system tools, system libraries, settings.

=alpine= is pulled from the Docker Registry, where hundreds of
thousands of images are hosted.
** Starting a container
#+BEGIN_SRC sh
  docker run alpine
#+END_SRC

What is happening here?
** Running a command
#+BEGIN_SRC sh
  docker run alpine echo "Hello from alpine!"
#+END_SRC
** Docker Status
List all docker images:
#+BEGIN_SRC sh
  docker images
#+END_SRC

List all running docker containers:
#+BEGIN_SRC sh
  docker ps
#+END_SRC

List all docker containers (including stopped containers):
#+BEGIN_SRC sh
  docker ps -a
#+END_SRC
** Entering a Container Interactively
#+BEGIN_SRC sh
  docker run -it alpine sh
#+END_SRC

#+BEGIN_SRC sh
  uname -r                        # 4.9.41-moby
  hostname                        # container_id
  whoami                          # root
  id                              # uid=0(root) gid=0(root) groups=0(root),1(bin)...
#+END_SRC

* Docker Networking
Docker creates three networks by default. We're mostly concerned with
=bridge=.

#+BEGIN_SRC text
  $ docker network ls

  NETWORK ID          NAME                DRIVER
  7fca4eb8c647        bridge              bridge
  9f904ee27bf5        none                null
  cf03ee007fb4        host                host
#+END_SRC
** How =bridge= works 
Unless specified otherwise, the docker container will connect to this
default =bridge= network. This provides a means of Docker containers
to access the outside world. This is achieved through rules on the
kernel's =iptable=.

By default, none of the ports are published and the outside world has
no access to the docker containers.
** Running a Simple Webserver
#+BEGIN_SRC sh
  nc -ll -p 8080 -e /bin/echo -e "HTTP/1.1 200 OK\n\n$(date)\n"
#+END_SRC
** Allowing Ingress
 #+BEGIN_SRC sh
   docker run -p 5001:8080 alpine \
          nc -ll -p 8080 -e /bin/echo -e "HTTP/1.1 200 OK\n\n$(date)\n"
 #+END_SRC

 As a daemon:
 #+BEGIN_SRC sh
   docker run -p 5001:8080 -d alpine \
          nc -ll -p 8080 -e /bin/echo -e "HTTP/1.1 200 OK\n\n$(date)\n"
 #+END_SRC
* Deploying a Node.js Server onto Docker
** Docker Images
 Docker images consist of multiple layers:

 #+ATTR_HTML: :width 60%
 [[file:images/docker/container-layers.jpg]]
** Layers for the ubuntu image
 Observe the output for the following:
 #+BEGIN_SRC sh
   docker pull ubuntu:15.04
   docker history ubuntu
 #+END_SRC
** Declare layers with a =Dockerfile=
#+BEGIN_SRC docker-file
  FROM ubuntu
  MAINTAINER Kimbro Staken

  RUN apt-get install -y software-properties-common python
  RUN add-apt-repository ppa:chris-lea/node.js
  RUN echo "deb http://us.archive.ubuntu.com/ubuntu/ precise universe" >> /etc/apt/sources.list
  RUN apt-get update
  RUN apt-get install -y nodejs
  #RUN apt-get install -y nodejs=0.6.12~dfsg1-1ubuntu1
  RUN mkdir /var/www

  ADD app.js /var/www/app.js

  CMD ["/usr/bin/node", "/var/www/app.js"] 
#+END_SRC
* But... I want to change my files!
#+BEGIN_SRC sh
  docker run -d my/webserver
  # Create file locally
  docker exec -it container_name sh
  ls #WAT
#+END_SRC
* Thank You
:PROPERTIES:
:SLIDE: thank-you-slide segue
:ASIDE: right
:ARTICLE: flexbox vleft auto-fadein
:END:
