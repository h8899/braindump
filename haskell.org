* Expressions
- Expressions include concrete values, variables, and also functions
- Functions are expressions that are applied to an argument, and hence
  can be /reduced/ or /evaluated/
* Infix/Prefix
#+BEGIN_SRC text
  div (prefix) -> `div` (infix)
  + (infix) -> (+) (prefix)
#+END_SRC
* Let vs Where
Let introduces an expression, so it can be used wherever you can have
an expression, but where is a declaration and is bound to a
surrounding syntactic construct.
* Typeclasses
Typeclasses are a way of adding additional functionality that is
reusable across all the types that have instances of that typeclass.
=Num= is a typeclass for most numeric types, that provide the basic
operators =(+)=, =(-)=, =(*)= , =(/)= etc.
* Datatype declaration
  A datatype declaration defines a type constructor and data
  constructors. Data constructors are the values of a particular type,
  and are also functions that let us create data, or values, of a
  particular type.
* Sectioning
  Refers to the partial application of infix operators.
#+BEGIN_SRC haskell
  let x = 5
  let y = (2^)
  let z = (^2)

  y x                             -- 32
  z x                             -- 25

  let celebrate = (++ " woot!")
  celebrate "naptime" -- "naptime woot!"
  celebrate "dogs" -- "dogs woot!"
#+END_SRC
* Types
** Polymorphism
1. Parametric polymorphism
   - Refers to type variables, or parameters, that are fully
     polymorphic
   - When unconstrained by a typeclass, the final concrete type could
     be anything
2. Constrained polymorphism
   - Puts typeclass constraints on the variable, decreasing the number
     of concrete types it could be, but increasing what you can
     actually do with it by defining and bringing into scope a set of
     operations

Numeric literals are polymorphic and stay so until given a more
specific type.
** Parametricity
 /parametricity/ means that the behaviour of a function with respect to
 the types its (parametric polymorphic) arguments is uniform. The
 behaviour cannot change just because it was applied to an argument of
 a different type.
** Making things more polymorphic
#+BEGIN_SRC haskell
  -- fromIntegral :: (Num b, Integral a) => a -> b
  -- e.g.
  6 / fromIntegral (length [1,2,3])
#+END_SRC
* Typeclasses
Where a declaration of a type defines how that particular type is
created, a declaration of a typeclass defines how a set of types are
consumed or used in computations.

As long as a type implements, or instantiates a typeclass, then
standard functions implemented on the typeclass can be used.

#+BEGIN_SRC haskell
  data DayOfWeek =
    Mon | Tue | Wed | Thu | Fri | Sat | Sun

  -- day of week and numerical day of month

  data Date =
    Date DayOfWeek Int
#+END_SRC

Because Eq is not derived in the typeclass, we need to instantiate one
of our own:

#+BEGIN_SRC haskell
  instance Eq DayOfWeek where
    (==) Mon Mon = True
    (==) Tue Tue = True
    (==) Wed Wed = True
    (==) Thu Thu = True
    (==) Fri Fri = True
    (==) Sat Sat = True
    (==) Sun Sun = True
    (==) _ _ = False

  instance Eq Date where
    (==) (Date weekday dayOfMonth) (Date weekday' dayOfMonth') =
      weekday == weekday' && dayOfMonth = dayOfMonth'
#+END_SRC

Typeclass instances are unique parings of the typeclass and a type.
They define the ways to implement the typeclass methods for that type.

** IO
An IO action is an action that, when performed, has side effects,
including reading from input and printing to the screen, and will
contain a return value.

In =IO ()=, =()= denotes an empty tuple, referred to as a /unit/. A
unit is both a value and a type, that has only one inhabitant.

** Summary
- A typeclass defines a set of functions and/or values;
- Types have instances of that typeclass
- The instances specify the ways that type uses the functions of the typeclass
* Lists
#+BEGIN_SRC haskell
  data [] a = [] | a : [a]
#+END_SRC
** Extracting portions of lists
#+BEGIN_SRC haskell
  take :: Int -> [a] -> [a]
  drop :: Int -> [a] -> [a]
  splitAt :: Int -> [a] -> ([a], [a])
#+END_SRC

#+BEGIN_SRC haskell
  takeWhile :: (a -> Bool) -> [a] -> [a]
  dropWhile :: (a -> Bool) -> [a] -> [a]
#+END_SRC
** Transforming lists of values
#+BEGIN_SRC haskell
  map :: (a -> b) -> [a] -> [b]
  fmap :: Functor f => (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
  map (+1) [1,2,3,4] -- [2,3,4,5]
  map (1-) [1,2,3,4] -- [0,-1,-2,-3]
#+END_SRC

#+BEGIN_SRC haskell
  filter :: (a -> Bool) -> [a] -> [a]
  filter _ [] = []
  filter pred (x:xs)
    | pred x = x : filter pred xs
    | otherwise = filter pred xs
#+END_SRC

#+BEGIN_SRC haskell
  zip :: [a] -> [b] -> [(a,b)]
  zip [1,2] [3,4] -- [(1,3), (2,4)]

  zipWith (+) [1,2,3] [10,11,12] -- [11,13,15]
#+END_SRC
** Folding lists
   Folds as a general concept are called /catamorphisms/.
   /Catamorphisms/ are a means of deconstructing data. If the spine of
   the list is the structure of a list, then a fold is what can reduce
   that structure.

#+BEGIN_SRC haskell
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr f z xs =
    case xs of
      [] -> z
      (x:xs) -> f x (foldr f z xs)
#+END_SRC
* Algebraic Datatypes
A type can be thought of as an enumeration of constructors that have
zero or more arguments.

Haskell offers sum types, product types, product types with record
syntax, type aliases, and a special datatype called a newtype that
offers a different set of options and constraints from either type
synonyms or data declarations.

#+BEGIN_SRC haskell
    data Bool = False | True
  -- [1] [2] [3] [4] [5] [6]

    data [] a = [] | a : [a]
  --     [7]   [8]    [9]
#+END_SRC

1. Keyword /data/ to signal that what follows is a data declaration,
   or a declaration of a datatype
2. Type constructor (with no arguments)
3. Equals sign divides the type constructor from the data constructor
4. Data constructor. In this case, a data constructor that takes no
   arguments, so is called a /nullary/ constructor.
5. Pipe denotes a sum type, which indicates a logical disjunction
   (colloquially /or/) in what values can have that type
6. Constructor for the value True, another nullary constructor
7. Type constructor with an argument. The argument is a polymorphic
   type variable, so the list's argument can be of different types
8. Data constructor for the empty list
9. Data constructor that takes two arguments, an a and also a [a]
** Data and type constructors
Type constructors are used only at the type level, in type signatures
and typeclass declarations and instances. Types are static and resolve
at compile time.

Data constructors construct the values at term level, values you can
interact with at runtime.

Type and data constructors that take no arguments are constants. They
can only store a fixed type and amount of data.
** Type constructors and kinds
Kinds are types of types, or types one level up. We represent kinds in
Haskell with =*=. We know something is a fully applied, concrete type
when it is represented as =*=. When it is =* -> *=, it is still
waiting to be applied.

#+BEGIN_SRC haskell
  -- :k Bool
  Bool :: *

  -- :k [Int]
  [Int] :: *

  -- :k []
  [] :: * -> *
#+END_SRC


Both =Bool= and [Int] are fully applied, concrete types, so their kind
signatures have no function arrows.
** Types vs Data
When data constructors take arguments, those arguments refer to other
types.

#+BEGIN_SRC haskell
  data Price =
    --  (a)
    Price Integer deriving (Eq, Show)
  -- (b)  [1]
  -- type constructor a
  -- data constructor b
  -- type argument [1]
#+END_SRC
** What makes these datatypes algebraic?
Algebraic datatypes are so, because we can describe the patterns of
argument structures using two basic operations: sum and product.

The cardinality of a datatype is the number of possible values it
defines. Knowing how many possible values inhabit a type can help
reason about programs.

The cardinality of =Bool= is 2, only being to take on =True= or =False=.

Datatypes that only contains a unary constructor always have the same
cardinality as the type they contain.

#+BEGIN_SRC haskell
  data Goats = Goats Int deriving (Eq, Show)
#+END_SRC

Here, =Goats= has the cardinality of =Int=.
** Sum Types
Cardinality is obtained through summation. Example, Bool:
#+BEGIN_SRC haskell
  data Bool = True | False
#+END_SRC

In this case, the cardinality of =Bool= is the sum of the cardinality
of =True= and =False=.
** Record syntax
#+BEGIN_SRC haskell
  data Person =
    Person { name :: String
           , age :: Int }
           deriving (Eq, Show)
#+END_SRC
