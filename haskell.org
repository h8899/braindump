* Expressions
- Expressions include concrete values, variables, and also functions
- Functions are expressions that are applied to an argument, and hence
  can be /reduced/ or /evaluated/
* Infix/Prefix
#+BEGIN_SRC text
  div (prefix) -> `div` (infix)
  + (infix) -> (+) (prefix)
#+END_SRC
* Let vs Where
Let introduces an expression, so it can be used wherever you can have
an expression, but where is a declaration and is bound to a
surrounding syntactic construct.
* Typeclasses
Typeclasses are a way of adding additional functionality that is
reusable across all the types that have instances of that typeclass.
=Num= is a typeclass for most numeric types, that provide the basic
operators =(+)=, =(-)=, =(*)= , =(/)= etc.
* Datatype declaration
  A datatype declaration defines a type constructor and data
  constructors. Data constructors are the values of a particular type,
  and are also functions that let us create data, or values, of a
  particular type.
* Sectioning
  Refers to the partial application of infix operators.
#+BEGIN_SRC haskell
  let x = 5
  let y = (2^)
  let z = (^2)

  y x                             -- 32
  z x                             -- 25

  let celebrate = (++ " woot!")
  celebrate "naptime" -- "naptime woot!"
  celebrate "dogs" -- "dogs woot!"
#+END_SRC
* Types
** Polymorphism
1. Parametric polymorphism
   - Refers to type variables, or parameters, that are fully
     polymorphic
   - When unconstrained by a typeclass, the final concrete type could
     be anything
2. Constrained polymorphism
   - Puts typeclass constraints on the variable, decreasing the number
     of concrete types it could be, but increasing what you can
     actually do with it by defining and bringing into scope a set of
     operations

Numeric literals are polymorphic and stay so until given a more
specific type.
** Parametricity
 /parametricity/ means that the behaviour of a function with respect to
 the types its (parametric polymorphic) arguments is uniform. The
 behaviour cannot change just because it was applied to an argument of
 a different type.
** Making things more polymorphic
#+BEGIN_SRC haskell
  -- fromIntegral :: (Num b, Integral a) => a -> b
  -- e.g.
  6 / fromIntegral (length [1,2,3])
#+END_SRC
* Typeclasses
Where a declaration of a type defines how that particular type is
created, a declaration of a typeclass defines how a set of types are
consumed or used in computations.

As long as a type implements, or instantiates a typeclass, then
standard functions implemented on the typeclass can be used.

#+BEGIN_SRC haskell
  data DayOfWeek =
    Mon | Tue | Wed | Thu | Fri | Sat | Sun

  -- day of week and numerical day of month

  data Date =
    Date DayOfWeek Int
#+END_SRC

Because Eq is not derived in the typeclass, we need to instantiate one
of our own:

#+BEGIN_SRC haskell
  instance Eq DayOfWeek where
    (==) Mon Mon = True
    (==) Tue Tue = True
    (==) Wed Wed = True
    (==) Thu Thu = True
    (==) Fri Fri = True
    (==) Sat Sat = True
    (==) Sun Sun = True
    (==) _ _ = False

  instance Eq Date where
    (==) (Date weekday dayOfMonth) (Date weekday' dayOfMonth') =
      weekday == weekday' && dayOfMonth = dayOfMonth'
#+END_SRC

Typeclass instances are unique parings of the typeclass and a type.
They define the ways to implement the typeclass methods for that type.

** IO
An IO action is an action that, when performed, has side effects,
including reading from input and printing to the screen, and will
contain a return value.

In =IO ()=, =()= denotes an empty tuple, referred to as a /unit/. A
unit is both a value and a type, that has only one inhabitant.

** Summary
- A typeclass defines a set of functions and/or values;
- Types have instances of that typeclass
- The instances specify the ways that type uses the functions of the typeclass
* Lists
#+BEGIN_SRC haskell
  data [] a = [] | a : [a]
#+END_SRC
** Extracting portions of lists
#+BEGIN_SRC haskell
  take :: Int -> [a] -> [a]
  drop :: Int -> [a] -> [a]
  splitAt :: Int -> [a] -> ([a], [a])
#+END_SRC

#+BEGIN_SRC haskell
  takeWhile :: (a -> Bool) -> [a] -> [a]
  dropWhile :: (a -> Bool) -> [a] -> [a]
#+END_SRC
** Transforming lists of values
#+BEGIN_SRC haskell
  map :: (a -> b) -> [a] -> [b]
  fmap :: Functor f => (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
  map (+1) [1,2,3,4] -- [2,3,4,5]
  map (1-) [1,2,3,4] -- [0,-1,-2,-3]
#+END_SRC

#+BEGIN_SRC haskell
  filter :: (a -> Bool) -> [a] -> [a]
  filter _ [] = []
  filter pred (x:xs)
    | pred x = x : filter pred xs
    | otherwise = filter pred xs
#+END_SRC

#+BEGIN_SRC haskell
  zip :: [a] -> [b] -> [(a,b)]
  zip [1,2] [3,4] -- [(1,3), (2,4)]

  zipWith (+) [1,2,3] [10,11,12] -- [11,13,15]
#+END_SRC
** Folding lists
   Folds as a general concept are called /catamorphisms/.
   /Catamorphisms/ are a means of deconstructing data. If the spine of
   the list is the structure of a list, then a fold is what can reduce
   that structure.

#+BEGIN_SRC haskell
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr f z xs =
    case xs of
      [] -> z
      (x:xs) -> f x (foldr f z xs)
#+END_SRC
* Algebraic Datatypes
A type can be thought of as an enumeration of constructors that have
zero or more arguments.

Haskell offers sum types, product types, product types with record
syntax, type aliases, and a special datatype called a newtype that
offers a different set of options and constraints from either type
synonyms or data declarations.

#+BEGIN_SRC haskell
    data Bool = False | True
  -- [1] [2] [3] [4] [5] [6]

    data [] a = [] | a : [a]
  --     [7]   [8]    [9]
#+END_SRC

1. Keyword /data/ to signal that what follows is a data declaration,
   or a declaration of a datatype
2. Type constructor (with no arguments)
3. Equals sign divides the type constructor from the data constructor
4. Data constructor. In this case, a data constructor that takes no
   arguments, so is called a /nullary/ constructor.
5. Pipe denotes a sum type, which indicates a logical disjunction
   (colloquially /or/) in what values can have that type
6. Constructor for the value True, another nullary constructor
7. Type constructor with an argument. The argument is a polymorphic
   type variable, so the list's argument can be of different types
8. Data constructor for the empty list
9. Data constructor that takes two arguments, an a and also a [a]
** Data and type constructors
Type constructors are used only at the type level, in type signatures
and typeclass declarations and instances. Types are static and resolve
at compile time.

Data constructors construct the values at term level, values you can
interact with at runtime.

Type and data constructors that take no arguments are constants. They
can only store a fixed type and amount of data.
** Type constructors and kinds
Kinds are types of types, or types one level up. We represent kinds in
Haskell with =*=. We know something is a fully applied, concrete type
when it is represented as =*=. When it is =* -> *=, it is still
waiting to be applied.

#+BEGIN_SRC haskell
  -- :k Bool
  Bool :: *

  -- :k [Int]
  [Int] :: *

  -- :k []
  [] :: * -> *
#+END_SRC


Both =Bool= and [Int] are fully applied, concrete types, so their kind
signatures have no function arrows.
** Types vs Data
When data constructors take arguments, those arguments refer to other
types.

#+BEGIN_SRC haskell
  data Price =
    --  (a)
    Price Integer deriving (Eq, Show)
  -- (b)  [1]
  -- type constructor a
  -- data constructor b
  -- type argument [1]
#+END_SRC
** What makes these datatypes algebraic?
Algebraic datatypes are so, because we can describe the patterns of
argument structures using two basic operations: sum and product.

The cardinality of a datatype is the number of possible values it
defines. Knowing how many possible values inhabit a type can help
reason about programs.

The cardinality of =Bool= is 2, only being to take on =True= or =False=.

Datatypes that only contains a unary constructor always have the same
cardinality as the type they contain.

#+BEGIN_SRC haskell
  data Goats = Goats Int deriving (Eq, Show)
#+END_SRC

Here, =Goats= has the cardinality of =Int=.
** Sum Types
Cardinality is obtained through summation. Example, Bool:
#+BEGIN_SRC haskell
  data Bool = True | False
#+END_SRC

In this case, the cardinality of =Bool= is the sum of the cardinality
of =True= and =False=.
** Record syntax
#+BEGIN_SRC haskell
  data Person =
    Person { name :: String
           , age :: Int }
           deriving (Eq, Show)
#+END_SRC
* Signaling Adversity
** Maybe
#+BEGIN_SRC haskell
  data Maybe = Just a | Nothing
#+END_SRC
#+BEGIN_SRC haskell
  type Name = String
  type Age = Integer

  data Person = Person Name Age Deriving (Eq, Show)

  mkPerson :: Name -> Age -> Maybe Person
  mkPerson name age
    | name /= "" && age >=0 = Just $ Person name age
    | otherwise = Nothing
#+END_SRC

mkPerson is a /smart constructor/. It allows us to construct values
only if it meets a certain criteria.
** Either
We use an =either= to figure out which criteria is not met:
#+BEGIN_SRC haskell
  data Either a b = Left a | Right b
#+END_SRC

#+BEGIN_SRC haskell
  data Person Invalid = NameEmpty | AgeTooLow deriving (Eq, Show)

  mkPerson :: Name -> Age -> Either PersonInvalid Person
  mkPerson name age
    | name /= "" && age >=0 - Right $ Person name age
    | name == "" = Left PersonInvalid
    | otherwise = Left AgeTooLow
#+END_SRC

=Left= is used as the invalid or error constructor. =Functor= will not
map over the left type argument because it has been applied away.
*** Signalling Multiple errors
#+BEGIN_SRC haskell
  type Name = String
  type Age = Integer
  type ValidatePerson a = Either [PersonInvalid] a

  data Person = Person Name Age deriving Show

  data PersonInvalid = NameEmpty | AgeTooLow deriving (Eq, Show)

  ageOkay :: Age -> Either [PersonInvalid] Age
  ageOkay age = case age >= 0 of
    True -> Right age
    False -> Left [AgeTooLow]

  nameOkay :: Name -> Either [PersonInvalid] Name
  nameOkay name = case name == "" of
    True -> Left [NameEmpty]
    False -> Right name

  mkPerson :: Name -> Age -> ValidatePerson Person
  mkPerson name age =
    mkPerson' (nameOkay name) (ageOkay age)

  mkPerson' :: ValidatePerson Name
            -> ValidatePerson Age
            -> ValidatePerson Person

  mkPerson' (Right nameOk) (Right ageOk) = Right (Person nameOk ageOk)
  mkPerson' (Left badName) (Left badAge) = Left (badName ++ badAge)
  mkPerson' (Left badName) _ = Left badName
  mkPerson' _ (Left badAge) = Left badAge
#+END_SRC
** Anamorphisms
/Anamorphisms/ are the dual of /catamorphisms/. Catamorphisms, or
folds, break data structures down, anamorphisms builds up data
structures.

#+BEGIN_SRC haskell
  -- iterate is like a very limited unfold that never ends
  iterate :: (a -> a) -> a -> [a]

  take 10 $ iterate (+1) 0
  [0,1,2,3,4,5,6,7,8,9]

  --unfoldr is more general
  unfoldr :: (b -> Maybe (a,b)) -> b -> [a]

  take 10 $ unfoldr (\b -> Just (b, b+1)) 0
  [0,1,2,3,4,5,6,7,8,9]
#+END_SRC
* Monoids
In Haskell, algebras are implemented with typeclasses; the typeclasses
define the set of operations. When we talk about operations over a
set, the set is the /type/ the operations are for.

One of those algebras we use in Haskell is Monoid.

=A monoid is a binary associative pattern with an identity.=

A monoid is a function that takes two arguments and follows two laws:
associativity and identity.

1. Associativity: arguments can be regrouped or paranthesised in
   different orders and give the same result
2. Identity: there exists some value such that when it is passed as
   input to the function, the operation is rendered moot and the other
   value is returned. E.g. adding 0, multiplying by 1

Monoids are the pattern of summation, multiplication and list
concatenation, among other things.

#+BEGIN_SRC haskell
  class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
#+END_SRC

=mappend= is how any two values that inhabit the type can be joined
together. =mempty= is the identity value for that mappend operation.
** Examples of Monoids
*** List
#+BEGIN_SRC haskell
  mappend [1,2,3] [4,5,6]
  -- [1,2,3,4,5,6]
  mconcat [[1..3], [4..6]]
  -- [1,2,3,4,5,6]
  mappend "Trout" " goes well with garlic"
  -- "Trout goes well with garlic"

  instance Monoid [a] where
    mempty = []
    mappend = (++)
#+END_SRC
*** Integers
Integers form a monoid under summation and multiplication. Because it
is unclear which rule is to be followed, there is no Monoid class
under Integer, but there is the =Sum= and =Product= types that signal
which Monoid instance is wanted.
** Newtype
Using =newtype= constrains the datatype to having a single unary data
constructor, and =newtype= guarantees no additional runtime overhead
in "wrapping" the original type. The runtime representation of newtype
and what it wraps are always identical.

#+BEGIN_SRC haskell
  (<>) :: Monoid m => m -> m -> m
#+END_SRC

=<>= is the infix version of =mappend=.

Monoid instances must abide by the following laws:

#+BEGIN_SRC haskell
  -- left identity
  mappend mempty x = x

  -- right identity
  mappend x mempty = x

  -- associativity
  mappend x (mappend y z) = mappend (mappend x y) z

  mconcat = foldr mappend mempty
#+END_SRC
** Monoid instances in =Bool=
#+BEGIN_SRC haskell
  All True <> All True
  -- All {getAll = True}

  All True <> All False
  -- All {getAll = False}

  Any True <> Any False
  -- Any {getAny = True}

  Any False <> Any False
  -- Any {getAny = False}
#+END_SRC

=All= represents boolean /conjuction/, while =Any= represents boolean disjunction.

For =Maybe=, =First= returns the "first" or leftmost non-Nothing
value. =Last= returns the "last" or rightmost non-Nothing value.

#+BEGIN_SRC haskell
  (First (Just 1)) <> (First (Just 2))
  -- First {getFirst = Just 1}
#+END_SRC

#+BEGIN_SRC haskell
  instance Monoid b => Monoid (a -> b)
  instance (Monoid a, Monoid b) => Monoid (a,b)
  instance (Monoid a, Monoid, b, Monoid c) => Monoid (a,b,c)
#+END_SRC
* Semigroups
Semigroups are like monoids, but without the identity constraint. The
core operation remains binary and associative.

#+BEGIN_SRC haskell
  class Semigroup a where
    (<>) :: a -> a -> a

  (a <> b) <> c = a <> (b <> c)
#+END_SRC

#+BEGIN_SRC haskell
  data NonEmpty a = a :| [a] deriving (Eq, Ord, Show)
#+END_SRC
* Functors
A functor is a way to apply a function over or around some structure
that we don't want to alter. That is, we want to apply the function to
the value that is "inside" some structure, and leave the structure
alone.

This is why functors are generally introduced by way of fmapping over
lists. No elements are removed or added, only transformed.

The typeclass =Functor= generalises this pattern, so that this basic
idea can be used across different structures.

#+BEGIN_SRC haskell
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
#+END_SRC

The argument =f a= is a Functor =f= that takes a type argument =a=.
That is, the =f= is a type that has an instance of the Functor
typeclass.

The return value is =f b=. It is the same =f= from =f a=, while the
type argument b /possibly but not necessarily/ refers to a different type.

/fmap/ specialises to different types as such:
#+BEGIN_SRC haskell
  fmap :: (a -> b) -> f a -> f b
  fmap :: (a -> b) -> [] a -> [] b
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap :: (a -> b) -> Just a -> Just b
  fmap :: (a -> b) -> Either a -> Either b
  fmap :: (a -> b) -> (e,) a -> (e,) b
  fmap :: (a -> b) -> Identity a -> Identity b
#+END_SRC
** Functor Laws
*** Identity
#+BEGIN_SRC haskell
  fmap id == id
#+END_SRC

If we fmap the identity function, it should have the same result as
passing our value to identity.
*** Composition
#+BEGIN_SRC haskell
  fmap (f . g) == fmap f . fmap g
#+END_SRC
*** Structure Preservation
#+BEGIN_SRC haskell
  fmap :: Functor f => (a -> b) -> f a -> f b
#+END_SRC

The /f/ is constrained by the typeclass Functor, but that is all we
know about its type from this definition. Because the /f/ persists
through the type of =fmap=, whatever the type is, we know it must be a
type that can take an argument, as in =f a= and =f b= and that it will
be the "structure" we're lifting the function over when we apply it to
the value inside.
** Examples
#+BEGIN_SRC haskell
  data WhoCares a =
    ItDoesnt
    | Matter a
    | WhatThisIsCalled
    deriving (Eq, Show)
#+END_SRC

In the above datatype, only =Matter= can be /fmapped/ over, because
the others are nullary, and there is no value to work with inside the
structure.

Here is a law-abiding instance of Functor.

#+BEGIN_SRC haskell
  instance Functor WhoCares where
    fmap _ ItDoesnt = ItDoesnt
    fmap _ WhatThisIsCalled = WhatThisIsCalled
    fmap f (Matter a) = Matter (f a)
#+END_SRC

This is a law-breaking instance:
#+BEGIN_SRC haskell
  instance Functor WhoCares where
    fmap _ ItDoesnt = WhatThisIsCalled
    fmap f WhatThisIsCalled = ItDoesnt
    fmap f (Matter a) = Matter (f a)
#+END_SRC

In this instance, the structure -- not the values wrapped or contained
within the structure -- change.
** Maybe and Either Functors
#+BEGIN_SRC haskell
  data Two a b = Two a b
#+END_SRC

Notice =Two= has the kind =* -> * -> *=, however, functors are of kind
=* -> *=, and hence functors on the type Two would be invalid. we can
reduce the kindness by doing the following:

#+BEGIN_SRC haskell
  instance Functor (Two a) where
    fmap f (Two a b) = Two a (f b)
#+END_SRC

Notice that we didn't apply =f= to =a=, because =a= is now part of the
Functor structure, and is untouchable.
** Ignoring possibilities
The Functor instances for the Maybe and Either datatypes are useful if
you tend to ignore the left cases, which are typically the error or
failure cases. Because fmap doesn't touch those cases, you can map
your function right to the values that you intend to work with and
ignore failure cases.
*** Maybe
#+BEGIN_SRC haskell
  incIfJust :: Num a => Maybe a -> Maybe a
  incIfJust (Just n) = Just $ n + 1
  incIfJust Nothing = Nothing

  incMaybe :: Num a => Maybe a -> Maybe a
  incMaybe = fmap (+1)
#+END_SRC
*** Either
#+BEGIN_SRC haskell
  incIfRight :: Num a => Either e a => Either e a
  incIfRight (Right n) = Right $ n + 1
  incIfRight (Left e) = Left e

  -- can be simplified to
  incEither :: Num a => Either e a => Either e a
  incEither = fmap (+1)
#+END_SRC
** Summary
=Functor= is a mapping between categories. In Haskell, this manifests
as a typeclass which lifts a function between to types over two new
types. This conventionally implies some notion of a function which can
be applied to a value with more structure than the unlifted function
was originally designed for. The additional structure is represented
by the use of a higher kinded type /f/, introduced by the definition
of the Functor typeclass.

To /lift over/, and later in Monad, to /bind over/, is a metaphor. One
way to think about it is that we can lift a function into a context.
Another is that we lift a function over some layer of structure to
apply it.

#+BEGIN_SRC haskell
  fmap (+1) $ Just 1 -- Just 2
  fmap (+1) [1,2,3] -- [2,3,4]
#+END_SRC

In both cases, the function we're lifting is the same. In the first
case, we lift that function into a Maybe context in order to apply it,
in the second case, into a list context.

The context determines how the function will get applied: the context
is the datatype, the definition of the datatype, and the Functor
instance we have for that datatype.
